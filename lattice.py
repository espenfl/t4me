# Copyright 2016 Espen Flage-Larsen
#
#    This file is part of T4ME.
#
#    T4ME is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    T4ME is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with T4ME.  If not, see <http://www.gnu.org/licenses/>.

#!/usr/bin/python
# python specifics
import sys
import math
import logging
import numpy as np
import xml.etree.cElementTree as ET
# locals
import utils
import inputoutput
import constants
import copy
import interface
import spglib_interface


class Lattice():
    """
    Contains routines to set up the system atmosphere; 
    e.g. unit cell, the BZ and IBZ k-point mesh etc.

    Read the YAML cell configuration file (cellparams.yml by
    default is used to read basic cell parameters if for instance
    this is not set up by other inputs in the :mod:`interface`)

    Parameters
    ----------
    param : object
        A `Param()` object containing the parameters of the
        general configuration file.

    """

    def __init__(self, param, location=None, filename=None):
        self.param = param
        self.kdata = self.Kmesh()
        if self.param.read == "param" or self.param.read[:5] == "numpy":
            interface.lattice_param_numpy(self, location=location,
                                          filename=filename)
        elif self.param.read == "vasp":
            interface.lattice_vasp(self, location=location,
                                   filename=filename)
        elif self.param.read == "w90":
            interface.lattice_w90(self, location=location,
                                  filename=filename)
        else:
            logging.info(
                "Not setting up the the lattice in a traditional manner.")

        # these are always present (as long as interface is
        # constructred properly), set internals
        self.kmesh = self.kdata.mesh
        self.kmesh_ired = self.kdata.mesh_ired
        self.mapping_bz_to_ibz = self.kdata.mapping_bz_to_ibz
        self.mapping_ibz_to_bz = self.kdata.mapping_ibz_to_bz
        self.ksampling = self.kdata.sampling
        self.ibz_weights = self.kdata.ibz_weights
        self.k_sort_index = self.kdata.k_sort_index

        # this one do nothing if both BZ, IBZ, mappings and weights are set
        # otherwise, it generates a new grid to set up these parameters
        # and crashes if it detects discrepancies
        self.generate_consistent_mesh()

        # calculate unit cell volume
        self.volume = self.calculate_cell_volume(self.unitcell)

        # calculate the recirpocal unit cell
        self.runitcell = self.real_to_rec()

        # calculate the reciprocal unit cell volume
        self.rvolume = self.calculate_cell_volume(self.runitcell)

        # check that we have at least set a minimal set
        # of parameters
        self.check_lattice()

    class Kmesh():
        """
        Data container for the k-point mesh generation. Currently
        not used throughout the program, only for the intial setup.

        .. todo:: Incorporate this class into the whole program.

        """

        def __init__(self):
            return

    def calculate_cell_volume(self, cell):
        """
        Calculates the cell volume.

        Parameters
        ----------
        cell : ndarray
            | Dimension: (3,3)

            Contains the i basis vectors of the cell, [i,:].

        Returns
        -------
        volume : float
            The volume of the cell in units of the units along
            the input axis cubed.

        """

        # set logger
        logger = logging.getLogger(sys._getframe().f_code.co_name)
        logger.debug("Running calculate_cell_volume.")

        volume = np.abs(np.dot(cell[0],
                               np.cross(cell[1],
                                        cell[2])))
        return volume

    def generate_consistent_mesh(self):
        """
        Calculates the k-point mesh and sets up proper mapping.
        Also makes sure the IBZ or BZ supplied is similar to
        the one generated by spglib given the symmetry used.

        Parameters
        ----------
        None

        Returns
        -------
        None

        Notes
        -----
        This should be reconsidered in the future as this is
        bound to give the user problems. Consider writing an
        interface which can accept the symmetry operators and use
        these directly.

        """

        # set logger
        logger = logging.getLogger(sys._getframe().f_code.co_name)
        logger.debug("Running generate_consistent_mesh.")

        if ((self.mapping_bz_to_ibz is None)
                or (self.mapping_ibz_to_bz is None)):
            if (self.kmesh is None) and (self.kmesh_ired is not None):
                # have IBZ, generate BZ
                kmesh = copy.deepcopy(self.kmesh_ired)
                self.create_kmesh_spg()
                if not np.allclose(kmesh, self.kmesh_ired,
                                   atol=self.param.symprec):
                    logger.error(
                        "The IBZ points does not correspond to the IBZ "
                        "points generated with spglib within symprec set at "
                        + str(self.param.symprec) + ". Exiting.")
                    logger.error("IBZ: " + str(kmesh) +
                                 "\n IBZ internal: " + str(self.kmesh_ired))
                    sys.exit(1)
            elif (self.kmesh_ired is None) and (self.kmesh is not None):
                # have BZ, generate IBZ
                kmesh = copy.deepcopy(self.kmesh)
                self.create_kmesh_spg()
                if not np.allclose(kmesh, self.kmesh,
                                   atol=self.param.symprec):
                    logger.error(
                        "The BZ points does not correspond to the BZ "
                        "points generated with spglib within symprec "
                        "set at " + str(self.param.symprec) + ". Exiting.")
                    logger.error("BZ: " + str(kmesh) +
                                 "\n BZ internal: " + str(self.kmesh))
                    sys.exit(1)
            elif (self.kmesh is None) and (self.kmesh_ired is None):
                self.create_kmesh_spg()

        # check that we at least have data present for the
        # essentials
        self.check_mesh()

    def check_lattice(self):
        """
        Checks if the celldata is present and that the most important
        parameters are defined.

        Parameters
        ----------
        None

        Returns
        -------
        None

        """

        # set logger
        logger = logging.getLogger(sys._getframe().f_code.co_name)
        logger.debug("Running check_lattice.")

        try:
            self.unitcell
            if self.unitcell is None:
                logger.error("The entry unitcell is still None. Exiting")
                sys.exit(1)
        except AttributeError:
            logger.error("Cannot find unitcell. Exiting.")
            sys.exit(1)

        try:
            self.runitcell
            if self.runitcell is None:
                logger.error("The entry runitcell is still None. Exiting")
                sys.exit(1)
        except AttributeError:
            logger.error("Cannot find runitcell. Exiting.")
            sys.exit(1)

        try:
            self.positions
            if self.positions is None:
                logger.error("The entry positions is still None. Exiting")
                sys.exit(1)
        except AttributeError:
            logger.error("Cannot find positions. Exiting.")
            sys.exit(1)

        try:
            self.species
            if self.species is None:
                logger.error("The entry species is still None. Exiting")
                sys.exit(1)
        except AttributeError:
            logger.error("Cannot find species. Exiting.")
            sys.exit(1)

        try:
            self.volume
            if self.volume is None:
                logger.error("The entry volume is still None. Exiting")
                sys.exit(1)
        except AttributeError:
            logger.error("Cannot find volume. Exiting.")
            sys.exit(1)

        try:
            self.rvolume
            if self.rvolume is None:
                logger.error("The entry rvolume is still None. Exiting")
                sys.exit(1)
        except AttributeError:
            logger.error("Cannot find rvolume. Exiting.")
            sys.exit(1)

        try:
            self.volume
            if self.volume is None:
                logger.error("The entry volume is still None. Exiting")
                sys.exit(1)
        except AttributeError:
            logger.error("Cannot find volume. Exiting.")
            sys.exit(1)

    def check_mesh(self):
        """
        Checks that the most important parameters for the k-point
        mesh have been set.

        Parameters
        ----------
        None

        Returns
        -------
        None

        """

        # set logger
        logger = logging.getLogger(sys._getframe().f_code.co_name)
        logger.debug("Running check_mesh")

        try:
            self.kmesh
            if self.kmesh is None:
                logger.error("The entry kmesh is still None. Exiting")
                sys.exit(1)
        except AttributeError:
            logger.error("Cannot find kmesh. Exiting.")
            sys.exit(1)

        try:
            self.kmesh_ired
            if self.kmesh_ired is None:
                logger.error("The entry kmesh_ired is still None. Exiting")
                sys.exit(1)
        except AttributeError:
            logger.error("Cannot find kmesh_ired. Exiting.")
            sys.exit(1)

        try:
            self.ksampling
            if self.ksampling is None:
                logger.error("The entry ksampling is still None. Exiting")
                sys.exit(1)
        except AttributeError:
            logger.error("Cannot find ksampling. Exiting.")
            sys.exit(1)

        try:
            self.mapping_bz_to_ibz
            if self.mapping_bz_to_ibz is None:
                logger.error(
                    "The entry mapping_bz_to_ibz is still None. Exiting")
                sys.exit(1)
        except AttributeError:
            logger.error("Cannot find mapping_bz_to_ibz. Exiting.")
            sys.exit(1)

        try:
            self.mapping_ibz_to_bz
            if self.mapping_ibz_to_bz is None:
                logger.error(
                    "The entry mapping_ibz_to_bz is still None. Exiting")
                sys.exit(1)
        except AttributeError:
            logger.error("Cannot find mapping_ibz_to_bz. Exiting.")
            sys.exit(1)

        try:
            self.ibz_weights
            if self.ibz_weights is None:
                logger.error(
                    "The entry ibz_weights is still None. Exiting")
                sys.exit(1)
        except AttributeError:
            logger.error("Cannot find ibz_weights. Exiting.")
            sys.exit(1)

    def fetch_kmesh(self, direct=True, ired=False):
        """
        Calculates the k point mesh in direct or 
        cartersian coordinates.

        Parameters
        ----------
        direct : boolean
            Selects the k-point grid in direct (True) or cartesian 
            coordinates (False)
        ired : boolean
            Selects the ireducible k-point grid (True), 
            or the full grid (False)

        Returns
        -------
        ndarray
            | Dimension: (M,3)

            Contains M k-points representing the k-point mesh.

        """

        # set logger
        logger = logging.getLogger(sys._getframe().f_code.co_name)
        logger.debug("Running fetch_kmesh.")

        if direct:
            if ired:
                return self.kmesh_ired
            else:
                return self.kmesh
        else:
            if ired:
                return self.dir_to_cart(self.kmesh_ired)
            else:
                return self.dir_to_cart(self.kmesh)

    def fetch_kmesh_unit_vecs(self, direct=True):
        """
        Calculates the k-point mesh sampling points along the
        unit vectors in direct or cartesian coordinates

        Parameters
        ----------
        direct : boolean
            Selects to return direct (True) or cartesian 
            (False) unit vectors.

        Returns
        -------
        ndarray
            | Dimension: (3)

            The unit vectors of the k-point mesh.

        """

        # set logger
        logger = logging.getLogger(sys._getframe().f_code.co_name)
        logger.debug("Running fetch_kmesh_unit_vecs.")

        if direct:
            kmesh_unit_vec = np.array([np.unique(self.kmesh[:, 0]),
                                       np.unique(self.kmesh[:, 1]),
                                       np.unique(self.kmesh[:, 2])])
        else:
            kmesh_cart = self.dir_to_cart(self.kmesh)
            kmesh_unit_vec = np.array([np.unique(kmesh_cart[:, 0]),
                                       np.unique(kmesh_cart[:, 1]),
                                       np.unique(kmesh_cart[:, 2])])
        return kmesh_unit_vec

    def fetch_kmesh_step_size(self):
        """
        Returns the :math:`k_x`, :math:`k_y` and :math:`k_z` step sizes
        in cartesian coordinates.

        Parameters
        ----------
        None

        Returns
        -------
        stepx, stepy, stepz : float, float, float
            The step size in each direction in the units
            of the k-point mesh.

        """

        # set logger
        logger = logging.getLogger(sys._getframe().f_code.co_name)
        logger.debug("Running fetch_kmesh_step_size.")

        kmesh = self.dir_to_cart(self.kmesh)
        stepz = kmesh[1][2] - kmesh[0][2]
        stepy = kmesh[self.ksampling[2]][1] - kmesh[0][1]
        stepx = kmesh[self.ksampling[2] * self.ksampling[1]][0] - kmesh[0][0]
        return stepx, stepy, stepz

    def fetch_kpoints_along_line(self, kstart, kend, stepping,
                                 direct=True):
        """
        Calculates the k-points along a line in the full BZ 
        k-point mesh

        Parameters
        ----------
        kstart : ndarray
            | Dimension: (3)

            The start k-point in direct coordinates.
        kend : ndarray
            | Dimension: (3)

            The end k-point in direct coordinates.
        stepping : int
            The N number of steps along the line.
        direct : boolean
            If True direct coordinates are returned, else 
            cartesian coordinates are returned.

        Returns
        -------
        ndarray
            | Dimension: (N)

            The N number of k-point cartesian coordinates 
            along the line.

        """

        # set logger
        logger = logging.getLogger(sys._getframe().f_code.co_name)
        logger.debug("Running fetch_kpoints_along_line.")
        sampx = np.linspace(kstart[0], kend[0], stepping)
        sampy = np.linspace(kstart[1], kend[1], stepping)
        sampz = np.linspace(kstart[2], kend[2], stepping)
        kx, ky, kz = np.meshgrid(sampx, sampy, sampz, sparse=True)
        kpts = np.vstack([kx.ravel(), ky.ravel(), kz.ravel()]).T
        # return
        if direct is False:
            kpts = self.dir_to_cart(kpts)
        return kpts

    def rec_to_real(self, unitcell=None):
        """
        Calculates the real unitcell from the reciprocal unitcell

        Parameters
        ----------
        unitcell : ndarray, optional
            | Dimension: (3,3)

            A reciprocal unitcell. Defaults to the internal 
            runitcell for the current `Lattice()` object.

        Returns
        -------
        ndarray
            | Dimension: (3,3)

            The real unitcell, with :math:`\\vec{a_1}`=[0][:] etc.

        """

        # set logger
        logger = logging.getLogger(sys._getframe().f_code.co_name)
        logger.debug("Running rec_to_real.")

        if unitcell is None:
            unitcell = self.runitcell

        return 2 * math.pi * np.linalg.inv(unitcell.transpose())

    def real_to_rec(self, unitcell=None):
        """
        Calculates the reciprocal unitcell from the real unitcell

        Parameters
        ----------
        unitcell : ndarray, optional
            | Dimension: (3,3)

            A real unitcell. Defaults to the unitcell for the
            current `Lattice()` object.

        Returns
        -------
        ndarray
            | Dimension: (3,3)

            The reciprocal unitcell, with :math:`\\vec{b_1}`=[0][:] 
            etc.

        """

        # set logger
        logger = logging.getLogger(sys._getframe().f_code.co_name)
        logger.debug("Running real_to_rec.")

        if unitcell is None:
            unitcell = self.unitcell

        ainv = 2 * math.pi * np.linalg.inv(unitcell)
        return np.ascontiguousarray(ainv.transpose(), dtype='double')

    def dir_to_cart(self, v, real=False):
        """
        Calculates the cartesian vector if the input is a vector in direct
        coordinates

        Parameters
        ----------
        v : ndarray
            | Dimension: (3)

            The supplied cartesian vector.
        real : boolean
            If set to False, the reciprocal unitcell is used,
            is set to True, the unitcell is used.

        Returns
        -------
        ndarray
            | Dimension: (3)

            The direct vector.

        """

        # set logger
        logger = logging.getLogger(sys._getframe().f_code.co_name)
        logger.debug("Running dir_to_cart.")

        if not real:
            cart = np.dot(v, self.runitcell)
        else:
            cart = np.dot(v, self.unitcell)

        return cart

    def cart_to_dir(self, v, real=False):
        """
        Calculates the direct vector if the input is a vector 
        in cartesian coordinates.

        Parameters
        ----------
        v : ndarray
            | Dimension: (3)

            The input direct vector.
        real : boolean
            If set to False, the reciprocal unitcell is used,
            is set to True, the unitcell is used.

        Returns
        -------
        ndarray
            | Dimension: (3)

            The cartesian vector.

        """

        # set logger
        logger = logging.getLogger(sys._getframe().f_code.co_name)
        logger.debug("Running cart_to_dir.")

        if not real:
            direct = np.dot(v, np.linalg.inv(self.runitcell))
        else:
            direct = np.dot(v, np.linalg.inv(self.unitcell))
        return direct

    def fetch_bz_border(self, kmesh=None, direct=True):
        """
        Returns the BZ border in direct
        or cartesian coordinates

        Parameters
        ----------
        kmesh : ndarray, optional
            | Dimension: (N,3)

            The k-point mesh for N k-points. If not supplied, 
            the value of the current `Lattice()` is used.
        direct : boolean, optional
            Selects if direct coordinates are to be returned
            (True, default) or cartesian (False).

        Returns
        -------
        ndarray
            | Dimension: (3)

            Contains the BZ border points (largest coordinate along 
            each axis).

        """

        # set logger
        logger = logging.getLogger(sys._getframe().f_code.co_name)
        logger.debug("Running fetch_bz_border.")

        if kmesh is None:
            kmesh = self.kmesh
        if direct is False:
            kmesh = self.dir_to_cart(kmesh)
        border = np.zeros(6)
        for i in range(3):
            border[2 * i] = np.amin(kmesh[:, i])
            border[2 * i + 1] = np.amax(kmesh[:, i])
        return border

    def create_kmesh_spg(self, ksampling=None,
                         shift=np.array([0, 0, 0], dtype='intc'),
                         halfscale=True, borderless=False):
        """
        Returns the k point mesh.

        Parameters
        ----------
        ksampling : ndarray, optional
            | Dimension: (3)

            Contains the k-point sampling points along each direction. 
            If not supplied the `ksampling` of the current `Lattice()` 
            object is used.
        shift : ndarray, optional
            | Dimension: (3)

            Contains the shift for the k-point mesh generation. 
            If not supplied the default is set to [0.0,0.0,0.0]
        halfscale : boolean
            Selects if the BZ mesh should go from -0.5 to 0.5 or 
            -1.0 to 1.0. If not supplied, the default is set to True.
        borderless : boolean
            Selects if the BZ border points should be included in 
            the mesh generation. True selects borderless, e.g. 
            -0.5, 0.5 etc. are excluded.

        Returns
        -------
        mapping_bz_to_ibz : ndarray
            | Dimension: (N,3)

            Contains a mapping table such that it is possible to go 
            from the BZ to the IBZ mesh. Stored in the current
            `Lattice()` object.
        mapping_ibz_to_bz : ndarray
            | Dimension: (M,3)

            Contains a mapping table such that it is possible to go 
            from the IBZ to the BZ mesh. Stored in the current
            `Lattice()` object.
        kmesh : ndarray
            | Dimension: (N,3)

            The k-point mesh in the full BZ for N sampling points 
            determined by the multiplication of the content of 
            `ksampling`. Stored in the current `Lattice()` object.
        kmesh_ibz : ndarray
            | Dimension: (M,3)

            The k-point mesh in the irreducible BZ. The number of 
            points M is dependent on the symmetry. Usually M < N. 
            Stored in the current `Lattice()` object.
        ksampling : ndarray
            | Dimension: (3)

            The full BZ k-point sampling in each direction. 
            Stored in the current `Lattice()` object.

        Notes
        -----
        This routines use spglib, an excellent tool written by A. Togo 
        :cite:`spglib`

        .. rubric:: References

        .. bibliography:: references.bib
           :style: unsrt
           :filter: docname in docnames

        """

        # set logger
        logger = logging.getLogger(sys._getframe().f_code.co_name)
        logger.debug("Running create_kmesh_spg.")

        if ksampling is None:
            try:
                ksampling = self.ksampling
            except AttributeError:
                logger.error("No ksampling is set. Exiting.")
                sys.exit(1)
        # check for gamma only
        if self.param.gamma_center:
            # up even ksampling grid to odd number
            if utils.is_even(ksampling[0]):
                ksampling[0] + 1
            if utils.is_even(ksampling[1]):
                ksampling[1] + 1
            if utils.is_even(ksampling[2]):
                ksampling[2] + 1
        else:
            logger.error(
                "Please set gamma centered to True and supply/generate "
                "a gamma centered grid. Exiting.")
            sys.exit(1)
        # make sure ksampling have correct dtype
        ksampling = np.ascontiguousarray(ksampling, dtype='intc')
        # same for the number of kpoints
        k = np.zeros((np.prod(ksampling), 3), dtype="intc")
        # and the mappings
        spg_mapping = np.zeros(np.prod(ksampling), dtype="intc")
        logger.info("Calling Spglib to set up the grid with a sampling "
                    "sampling of " + str(ksampling[0]) + "x" +
                    str(ksampling[0]) + "x" + str(ksampling[2]) + ".")
        if self.param.read == "vasp" or borderless:
            logger.info(
                "Running borderless compatible k-point generation etc. "
                "(VASP, SKW, etc.)")
            # VASP does not include bz borders in the k-point set
            # call spglib with symprec 10 times vasp value
            spglib_interface.get_reciprocal_mesh(
                ksampling, np.ascontiguousarray(self.unitcell.T),
                self.positions, self.species, shift, k,
                spg_mapping, is_time_reversal=False, symprec=1e-6)
        else:
            # call spglib
            spglib_interface.get_reciprocal_mesh(
                ksampling, np.ascontiguousarray(self.unitcell.T),
                self.positions, self.species, shift, k,
                spg_mapping, is_time_reversal=True, symprec=1e-4)
        # build array for IBZ
        k_ired = k[np.unique(spg_mapping, return_index=True)[1]]
        # sort mesh
        k_sort_ired = np.lexsort((k_ired[:, 2], k_ired[:, 1], k_ired[:, 0]))
        k_sort_full = np.lexsort((k[:, 2], k[:, 1], k[:, 0]))
        kmesh_ired = k_ired[k_sort_ired]
        kmesh_full = k[k_sort_full]

        # store original SPGLIB mesh for use later
        # (e.g. tetrahedron method)
        self.spg_kmesh = k[k_sort_full]

        shuffle = np.zeros(spg_mapping.shape[0], dtype=np.intc)
        for index, value in enumerate(spg_mapping):
            shuffle[index] = np.where(k_sort_full == value)[0][0]
        # build ired and sort
        k_ired = kmesh_full[
            shuffle[np.sort(np.unique(shuffle,
                                      return_index=True)[1])]]
        k_ired = k_ired[np.lexsort((k_ired[:, 2],
                                    k_ired[:, 1],
                                    k_ired[:, 0]))]
        mapping_ibz_to_bz = shuffle[k_sort_full]
        mapping_bz_to_ibz = np.zeros(mapping_ibz_to_bz.size, dtype=np.intc)
        for index, ibz_point in enumerate(np.unique(mapping_ibz_to_bz)):
            mask = np.in1d(mapping_ibz_to_bz, ibz_point)
            np.copyto(mapping_bz_to_ibz, index, where=mask)

        # scale the grid from integer to float (consider to postpone this
        # in the future...e.g. integers are nice because test for uniqueness
        # is exact etc.)
        if self.param.read == "vasp" or borderless:
            scaling = 1.0 / ksampling
            kmesh_full = kmesh_full * scaling
            kmesh_ired = kmesh_ired * scaling
        else:
            scaling = np.floor(ksampling / 2.0)
            kmesh_full = kmesh_full / scaling
            kmesh_ired = kmesh_ired / scaling
            if halfscale:
                kmesh_full = 0.5 * kmesh_full
                kmesh_ired = 0.5 * kmesh_ired

        # calculate ibz weights
        dummy, ibz_weights = np.unique(mapping_bz_to_ibz, return_counts=True)

        self.kmesh = kmesh_full
        self.kmesh_ired = kmesh_ired
        self.mapping_ibz_to_bz = np.unique(mapping_ibz_to_bz)
        self.mapping_bz_to_ibz = mapping_bz_to_ibz
        self.ksampling = ksampling
        self.ibz_weights = ibz_weights
